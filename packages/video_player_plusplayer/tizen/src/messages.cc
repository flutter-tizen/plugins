// Copyright 2022 Samsung Electronics Co., Ltd. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v3.1.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

/* TextureMessage */

int64_t TextureMessage::texture_id() const { return texture_id_; }
void TextureMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

flutter::EncodableMap TextureMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
  };
}

TextureMessage::TextureMessage() {}

TextureMessage::TextureMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
}

/* LoopingMessage */

int64_t LoopingMessage::texture_id() const { return texture_id_; }
void LoopingMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

bool LoopingMessage::is_looping() const { return is_looping_; }
void LoopingMessage::set_is_looping(bool value_arg) { is_looping_ = value_arg; }

flutter::EncodableMap LoopingMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("isLooping"),
       flutter::EncodableValue(is_looping_)},
  };
}

LoopingMessage::LoopingMessage() {}

LoopingMessage::LoopingMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_is_looping = map.at(flutter::EncodableValue("isLooping"));
  if (const bool* pointer_is_looping =
          std::get_if<bool>(&encodable_is_looping)) {
    is_looping_ = *pointer_is_looping;
  }
}

/* VolumeMessage */

int64_t VolumeMessage::texture_id() const { return texture_id_; }
void VolumeMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

double VolumeMessage::volume() const { return volume_; }
void VolumeMessage::set_volume(double value_arg) { volume_ = value_arg; }

flutter::EncodableMap VolumeMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("volume"), flutter::EncodableValue(volume_)},
  };
}

VolumeMessage::VolumeMessage() {}

VolumeMessage::VolumeMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_volume = map.at(flutter::EncodableValue("volume"));
  if (const double* pointer_volume = std::get_if<double>(&encodable_volume)) {
    volume_ = *pointer_volume;
  }
}

/* PlaybackSpeedMessage */

int64_t PlaybackSpeedMessage::texture_id() const { return texture_id_; }
void PlaybackSpeedMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

double PlaybackSpeedMessage::speed() const { return speed_; }
void PlaybackSpeedMessage::set_speed(double value_arg) { speed_ = value_arg; }

flutter::EncodableMap PlaybackSpeedMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("speed"), flutter::EncodableValue(speed_)},
  };
}

PlaybackSpeedMessage::PlaybackSpeedMessage() {}

PlaybackSpeedMessage::PlaybackSpeedMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_speed = map.at(flutter::EncodableValue("speed"));
  if (const double* pointer_speed = std::get_if<double>(&encodable_speed)) {
    speed_ = *pointer_speed;
  }
}

/* PositionMessage */

int64_t PositionMessage::texture_id() const { return texture_id_; }
void PositionMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

int64_t PositionMessage::position() const { return position_; }
void PositionMessage::set_position(int64_t value_arg) { position_ = value_arg; }

flutter::EncodableMap PositionMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("position"), flutter::EncodableValue(position_)},
  };
}

PositionMessage::PositionMessage() {}

PositionMessage::PositionMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_position = map.at(flutter::EncodableValue("position"));
  if (const int32_t* pointer_position =
          std::get_if<int32_t>(&encodable_position))
    position_ = *pointer_position;
  else if (const int64_t* pointer_position_64 =
               std::get_if<int64_t>(&encodable_position))
    position_ = *pointer_position_64;
}

/* CreateMessage */

const std::string* CreateMessage::asset() const {
  return asset_ ? &(*asset_) : nullptr;
}
void CreateMessage::set_asset(const std::string_view* value_arg) {
  asset_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void CreateMessage::set_asset(std::string_view value_arg) {
  asset_ = value_arg;
}

const std::string* CreateMessage::uri() const {
  return uri_ ? &(*uri_) : nullptr;
}
void CreateMessage::set_uri(const std::string_view* value_arg) {
  uri_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void CreateMessage::set_uri(std::string_view value_arg) { uri_ = value_arg; }

const std::string* CreateMessage::package_name() const {
  return package_name_ ? &(*package_name_) : nullptr;
}
void CreateMessage::set_package_name(const std::string_view* value_arg) {
  package_name_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void CreateMessage::set_package_name(std::string_view value_arg) {
  package_name_ = value_arg;
}

const std::string* CreateMessage::format_hint() const {
  return format_hint_ ? &(*format_hint_) : nullptr;
}
void CreateMessage::set_format_hint(const std::string_view* value_arg) {
  format_hint_ =
      value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}
void CreateMessage::set_format_hint(std::string_view value_arg) {
  format_hint_ = value_arg;
}

const flutter::EncodableMap* CreateMessage::http_headers() const {
  return http_headers_ ? &(*http_headers_) : nullptr;
}
void CreateMessage::set_http_headers(const flutter::EncodableMap* value_arg) {
  http_headers_ = value_arg ? std::optional<flutter::EncodableMap>(*value_arg)
                            : std::nullopt;
}
void CreateMessage::set_http_headers(const flutter::EncodableMap& value_arg) {
  http_headers_ = value_arg;
}

const flutter::EncodableMap* CreateMessage::drm_configs() const {
  return drm_configs_ ? &(*drm_configs_) : nullptr;
}
void CreateMessage::set_drm_configs(const flutter::EncodableMap* value_arg) {
  drm_configs_ = value_arg ? std::optional<flutter::EncodableMap>(*value_arg)
                           : std::nullopt;
}
void CreateMessage::set_drm_configs(const flutter::EncodableMap& value_arg) {
  drm_configs_ = value_arg;
}

flutter::EncodableMap CreateMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("asset"),
       asset_ ? flutter::EncodableValue(*asset_) : flutter::EncodableValue()},
      {flutter::EncodableValue("uri"),
       uri_ ? flutter::EncodableValue(*uri_) : flutter::EncodableValue()},
      {flutter::EncodableValue("packageName"),
       package_name_ ? flutter::EncodableValue(*package_name_)
                     : flutter::EncodableValue()},
      {flutter::EncodableValue("formatHint"),
       format_hint_ ? flutter::EncodableValue(*format_hint_)
                    : flutter::EncodableValue()},
      {flutter::EncodableValue("httpHeaders"),
       http_headers_ ? flutter::EncodableValue(*http_headers_)
                     : flutter::EncodableValue()},
      {flutter::EncodableValue("drmConfigs"),
       drm_configs_ ? flutter::EncodableValue(*drm_configs_)
                    : flutter::EncodableValue()},
  };
}

CreateMessage::CreateMessage() {}

CreateMessage::CreateMessage(flutter::EncodableMap map) {
  auto encodable_asset = map.at(flutter::EncodableValue("asset"));
  if (const std::string* pointer_asset =
          std::get_if<std::string>(&encodable_asset)) {
    asset_ = *pointer_asset;
  }
  auto encodable_uri = map.at(flutter::EncodableValue("uri"));
  if (const std::string* pointer_uri =
          std::get_if<std::string>(&encodable_uri)) {
    uri_ = *pointer_uri;
  }
  auto encodable_package_name = map.at(flutter::EncodableValue("packageName"));
  if (const std::string* pointer_package_name =
          std::get_if<std::string>(&encodable_package_name)) {
    package_name_ = *pointer_package_name;
  }
  auto encodable_format_hint = map.at(flutter::EncodableValue("formatHint"));
  if (const std::string* pointer_format_hint =
          std::get_if<std::string>(&encodable_format_hint)) {
    format_hint_ = *pointer_format_hint;
  }
  auto encodable_http_headers = map.at(flutter::EncodableValue("httpHeaders"));
  if (const flutter::EncodableMap* pointer_http_headers =
          std::get_if<flutter::EncodableMap>(&encodable_http_headers)) {
    http_headers_ = *pointer_http_headers;
  }
  auto encodable_drm_configs = map.at(flutter::EncodableValue("drmConfigs"));
  if (const flutter::EncodableMap* pointer_drm_configs =
          std::get_if<flutter::EncodableMap>(&encodable_drm_configs)) {
    drm_configs_ = *pointer_drm_configs;
  }
}

/* MixWithOthersMessage */

bool MixWithOthersMessage::mix_with_others() const { return mix_with_others_; }
void MixWithOthersMessage::set_mix_with_others(bool value_arg) {
  mix_with_others_ = value_arg;
}

flutter::EncodableMap MixWithOthersMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("mixWithOthers"),
       flutter::EncodableValue(mix_with_others_)},
  };
}

MixWithOthersMessage::MixWithOthersMessage() {}

MixWithOthersMessage::MixWithOthersMessage(flutter::EncodableMap map) {
  auto encodable_mix_with_others =
      map.at(flutter::EncodableValue("mixWithOthers"));
  if (const bool* pointer_mix_with_others =
          std::get_if<bool>(&encodable_mix_with_others)) {
    mix_with_others_ = *pointer_mix_with_others;
  }
}

/* GeometryMessage */

int64_t GeometryMessage::texture_id() const { return texture_id_; }
void GeometryMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

int64_t GeometryMessage::x() const { return x_; }
void GeometryMessage::set_x(int64_t value_arg) { x_ = value_arg; }

int64_t GeometryMessage::y() const { return y_; }
void GeometryMessage::set_y(int64_t value_arg) { y_ = value_arg; }

int64_t GeometryMessage::w() const { return w_; }
void GeometryMessage::set_w(int64_t value_arg) { w_ = value_arg; }

int64_t GeometryMessage::h() const { return h_; }
void GeometryMessage::set_h(int64_t value_arg) { h_ = value_arg; }

flutter::EncodableMap GeometryMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("x"), flutter::EncodableValue(x_)},
      {flutter::EncodableValue("y"), flutter::EncodableValue(y_)},
      {flutter::EncodableValue("w"), flutter::EncodableValue(w_)},
      {flutter::EncodableValue("h"), flutter::EncodableValue(h_)},
  };
}

GeometryMessage::GeometryMessage() {}

GeometryMessage::GeometryMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_x = map.at(flutter::EncodableValue("x"));
  if (const int32_t* pointer_x = std::get_if<int32_t>(&encodable_x))
    x_ = *pointer_x;
  else if (const int64_t* pointer_x_64 = std::get_if<int64_t>(&encodable_x))
    x_ = *pointer_x_64;
  auto encodable_y = map.at(flutter::EncodableValue("y"));
  if (const int32_t* pointer_y = std::get_if<int32_t>(&encodable_y))
    y_ = *pointer_y;
  else if (const int64_t* pointer_y_64 = std::get_if<int64_t>(&encodable_y))
    y_ = *pointer_y_64;
  auto encodable_w = map.at(flutter::EncodableValue("w"));
  if (const int32_t* pointer_w = std::get_if<int32_t>(&encodable_w))
    w_ = *pointer_w;
  else if (const int64_t* pointer_w_64 = std::get_if<int64_t>(&encodable_w))
    w_ = *pointer_w_64;
  auto encodable_h = map.at(flutter::EncodableValue("h"));
  if (const int32_t* pointer_h = std::get_if<int32_t>(&encodable_h))
    h_ = *pointer_h;
  else if (const int64_t* pointer_h_64 = std::get_if<int64_t>(&encodable_h))
    h_ = *pointer_h_64;
}

/* BufferingConfigMessage */

int64_t BufferingConfigMessage::texture_id() const { return texture_id_; }
void BufferingConfigMessage::set_texture_id(int64_t value_arg) {
  texture_id_ = value_arg;
}

const std::string& BufferingConfigMessage::buffer_option() const {
  return buffer_option_;
}
void BufferingConfigMessage::set_buffer_option(std::string_view value_arg) {
  buffer_option_ = value_arg;
}

int64_t BufferingConfigMessage::amount() const { return amount_; }
void BufferingConfigMessage::set_amount(int64_t value_arg) {
  amount_ = value_arg;
}

flutter::EncodableMap BufferingConfigMessage::ToEncodableMap() const {
  return flutter::EncodableMap{
      {flutter::EncodableValue("textureId"),
       flutter::EncodableValue(texture_id_)},
      {flutter::EncodableValue("bufferOption"),
       flutter::EncodableValue(buffer_option_)},
      {flutter::EncodableValue("amount"), flutter::EncodableValue(amount_)},
  };
}

BufferingConfigMessage::BufferingConfigMessage() {}

BufferingConfigMessage::BufferingConfigMessage(flutter::EncodableMap map) {
  auto encodable_texture_id = map.at(flutter::EncodableValue("textureId"));
  if (const int32_t* pointer_texture_id =
          std::get_if<int32_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id;
  else if (const int64_t* pointer_texture_id_64 =
               std::get_if<int64_t>(&encodable_texture_id))
    texture_id_ = *pointer_texture_id_64;
  auto encodable_buffer_option =
      map.at(flutter::EncodableValue("bufferOption"));
  if (const std::string* pointer_buffer_option =
          std::get_if<std::string>(&encodable_buffer_option)) {
    buffer_option_ = *pointer_buffer_option;
  }
  auto encodable_amount = map.at(flutter::EncodableValue("amount"));
  if (const int32_t* pointer_amount = std::get_if<int32_t>(&encodable_amount))
    amount_ = *pointer_amount;
  else if (const int64_t* pointer_amount_64 =
               std::get_if<int64_t>(&encodable_amount))
    amount_ = *pointer_amount_64;
}

VideoPlayerApiCodecSerializer::VideoPlayerApiCodecSerializer() {}
flutter::EncodableValue VideoPlayerApiCodecSerializer::ReadValueOfType(
    uint8_t type, flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return flutter::CustomEncodableValue(BufferingConfigMessage(
          std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 129:
      return flutter::CustomEncodableValue(
          CreateMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 130:
      return flutter::CustomEncodableValue(
          GeometryMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 131:
      return flutter::CustomEncodableValue(
          LoopingMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 132:
      return flutter::CustomEncodableValue(MixWithOthersMessage(
          std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 133:
      return flutter::CustomEncodableValue(PlaybackSpeedMessage(
          std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 134:
      return flutter::CustomEncodableValue(
          PositionMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 135:
      return flutter::CustomEncodableValue(
          TextureMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    case 136:
      return flutter::CustomEncodableValue(
          VolumeMessage(std::get<flutter::EncodableMap>(ReadValue(stream))));

    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void VideoPlayerApiCodecSerializer::WriteValue(
    const flutter::EncodableValue& value,
    flutter::ByteStreamWriter* stream) const {
  if (const flutter::CustomEncodableValue* custom_value =
          std::get_if<flutter::CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(BufferingConfigMessage)) {
      stream->WriteByte(128);
      WriteValue(flutter::EncodableValue(
                     std::any_cast<BufferingConfigMessage>(*custom_value)
                         .ToEncodableMap()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(CreateMessage)) {
      stream->WriteByte(129);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<CreateMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(GeometryMessage)) {
      stream->WriteByte(130);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<GeometryMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(LoopingMessage)) {
      stream->WriteByte(131);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<LoopingMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(MixWithOthersMessage)) {
      stream->WriteByte(132);
      WriteValue(flutter::EncodableValue(
                     std::any_cast<MixWithOthersMessage>(*custom_value)
                         .ToEncodableMap()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PlaybackSpeedMessage)) {
      stream->WriteByte(133);
      WriteValue(flutter::EncodableValue(
                     std::any_cast<PlaybackSpeedMessage>(*custom_value)
                         .ToEncodableMap()),
                 stream);
      return;
    }
    if (custom_value->type() == typeid(PositionMessage)) {
      stream->WriteByte(134);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<PositionMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(TextureMessage)) {
      stream->WriteByte(135);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<TextureMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
    if (custom_value->type() == typeid(VolumeMessage)) {
      stream->WriteByte(136);
      WriteValue(
          flutter::EncodableValue(
              std::any_cast<VolumeMessage>(*custom_value).ToEncodableMap()),
          stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/** The codec used by VideoPlayerApi. */
const flutter::StandardMessageCodec& VideoPlayerApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(
      &VideoPlayerApiCodecSerializer::GetInstance());
}

/** Sets up an instance of `VideoPlayerApi` to handle messages through the
 * `binary_messenger`. */
void VideoPlayerApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                           VideoPlayerApi* api) {
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.initialize",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              std::optional<FlutterError> output = api->Initialize();
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.create",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const CreateMessage& msg_arg =
                  std::any_cast<const CreateMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              ErrorOr<std::unique_ptr<TextureMessage>> output =
                  api->Create(msg_arg);
              if (output.hasError()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.error())));
              } else {
                if (!output.value()) {
                  wrapped.insert(std::make_pair(
                      flutter::EncodableValue("error"),
                      WrapError("output is unexpectedly null.")));
                } else {
                  wrapped.insert(std::make_pair(
                      flutter::EncodableValue("result"),
                      flutter::CustomEncodableValue(*output.value().get())));
                }
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.dispose",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const TextureMessage& msg_arg =
                  std::any_cast<const TextureMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->Dispose(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.setLooping",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const LoopingMessage& msg_arg =
                  std::any_cast<const LoopingMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->SetLooping(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.setVolume",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const VolumeMessage& msg_arg =
                  std::any_cast<const VolumeMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->SetVolume(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.VideoPlayerApi.setPlaybackSpeed", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const PlaybackSpeedMessage& msg_arg =
                  std::any_cast<const PlaybackSpeedMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output =
                  api->SetPlaybackSpeed(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.play",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const TextureMessage& msg_arg =
                  std::any_cast<const TextureMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->Play(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.position",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const TextureMessage& msg_arg =
                  std::any_cast<const TextureMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              ErrorOr<std::unique_ptr<PositionMessage>> output =
                  api->Position(msg_arg);
              if (output.hasError()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.error())));
              } else {
                if (!output.value()) {
                  wrapped.insert(std::make_pair(
                      flutter::EncodableValue("error"),
                      WrapError("output is unexpectedly null.")));
                } else {
                  wrapped.insert(std::make_pair(
                      flutter::EncodableValue("result"),
                      flutter::CustomEncodableValue(*output.value().get())));
                }
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.seekTo",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const PositionMessage& msg_arg =
                  std::any_cast<const PositionMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->SeekTo(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.pause",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const TextureMessage& msg_arg =
                  std::any_cast<const TextureMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output = api->Pause(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.VideoPlayerApi.setMixWithOthers", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_msg_arg = args.at(0);
              if (encodable_msg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("msg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const MixWithOthersMessage& msg_arg =
                  std::any_cast<const MixWithOthersMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_msg_arg));
              std::optional<FlutterError> output =
                  api->SetMixWithOthers(msg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger, "dev.flutter.pigeon.VideoPlayerApi.setDisplayRoi",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_arg_arg = args.at(0);
              if (encodable_arg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("arg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const GeometryMessage& arg_arg =
                  std::any_cast<const GeometryMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_arg_arg));
              std::optional<FlutterError> output = api->SetDisplayRoi(arg_arg);
              if (output.has_value()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.value())));
              } else {
                wrapped.insert(std::make_pair(flutter::EncodableValue("result"),
                                              flutter::EncodableValue()));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel =
        std::make_unique<flutter::BasicMessageChannel<flutter::EncodableValue>>(
            binary_messenger,
            "dev.flutter.pigeon.VideoPlayerApi.setBufferingConfig",
            &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const flutter::EncodableValue& message,
                const flutter::MessageReply<flutter::EncodableValue>& reply) {
            flutter::EncodableMap wrapped;
            try {
              auto args = std::get<flutter::EncodableList>(message);
              auto encodable_arg_arg = args.at(0);
              if (encodable_arg_arg.IsNull()) {
                wrapped.insert(
                    std::make_pair(flutter::EncodableValue("error"),
                                   WrapError("arg_arg unexpectedly null.")));
                reply(flutter::EncodableValue(wrapped));
                return;
              }
              const BufferingConfigMessage& arg_arg =
                  std::any_cast<const BufferingConfigMessage&>(
                      std::get<flutter::CustomEncodableValue>(
                          encodable_arg_arg));
              ErrorOr<bool> output = api->SetBufferingConfig(arg_arg);
              if (output.hasError()) {
                wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                              WrapError(output.error())));
              } else {
                wrapped.insert(std::make_pair(
                    flutter::EncodableValue("result"),
                    flutter::CustomEncodableValue(output.value())));
              }
            } catch (const std::exception& exception) {
              wrapped.insert(std::make_pair(flutter::EncodableValue("error"),
                                            WrapError(exception.what())));
            }
            reply(flutter::EncodableValue(wrapped));
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

flutter::EncodableMap VideoPlayerApi::WrapError(
    std::string_view error_message) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(std::string(error_message).data())},
       {flutter::EncodableValue("code"), flutter::EncodableValue("Error")},
       {flutter::EncodableValue("details"), flutter::EncodableValue()}});
}
flutter::EncodableMap VideoPlayerApi::WrapError(const FlutterError& error) {
  return flutter::EncodableMap(
      {{flutter::EncodableValue("message"),
        flutter::EncodableValue(error.message)},
       {flutter::EncodableValue("code"), flutter::EncodableValue(error.code)},
       {flutter::EncodableValue("details"), error.details}});
}
